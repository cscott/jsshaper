Support yield via a limited-scope CPS conversion.

Pass in value and exception as function arguments to avoid creating objects
on every closure invocation.  Refer to these as arguments[0] and arguments[1]
to avoid pollution the name space.

Pass in array of continuations to Generator constructor to avoid
exposing it to namespace, then use integers instead of functions
as values of the cont: property in return values.

Optimize looping return as common case (ie, return a simple integer
in this case, instead of creating an object wrapper).   This makes loops
as fast as possible.

// Sample source for yield conversion:

function bat(arr) {
  var i;
  // [0]
  for (i=0; i<arr.length; i++) {
     // [1]
     if (test.apply(arr[i], arguments)) {
       // [2]
       try {
         // [3]
         something();
         var j = /* [4] */yield arr[i];
         if (j) {
           // [5]
           something(j);
           return;
         }
         // [6]
       } catch (e) {
         // [7]
         log(e);
         delete arr[i];
       } finally {
         // [8]
         baz(i);
       }
       // [9]
     }
     // [10]
  }
  // [11]
  return;
}

// This gets converted to:

function bat(arr) {
  var $stop = {};
  var $arguments = arguments; // necessary because original uses 'arguments'
  var $catch$e;               // necessary because original has catch
  var $finally;               // necessary because original has finally
  var i, j;
  return new Generator(this, $stop, [
    function() { // [0] (external, but first: don't need to check arguments[0])
       i = 0;
       return 1; // looping continuation
    },
    function() { // [1] (internal)
       // internal looping continuation, don't need to check arguments[0] for ex
       // "if (!(i < arr.length)) break;"
       if (i >= arr.length) { return 11; /* looping continuation, after loop */ }
       if (test.apply(arr[i], $arguments)) {
           return 2;
       }
       return 10;
    },
    function() { // [2] (internal)
       return 3; // top of try
    },
    function() { // [3] (internal)
       try {
         something();
         return { cont: 4, ret: arr[i] }; // yield
       } catch (e) {
         if (e===$stop) {
           // (would rethrow e if there wasn't a finally block)
           return { cont:8, ex:e, again:true; }; // branch to finally
         }
         return { cont:7, ex:e, again:true; }; // branch to catch
       }
    },
    function() { // [4] (external)
      try {
        // external continuation, need to check arguments[0]
        if (arguments[0]) { throw arguments[0]; }
        j = arguments[1];
        if (j) return 5;
        return 6;
      } catch (e) {
         if (e===$stop) {
           return { cont:8, ex:e, again:true; }; // branch to finally
         }
         return { cont:7, ex:e, again:true; }; // branch to catch
      }
    },
    function() { // [5] (internal)
      try {
        something(j);
        throw $stop; // return
      } catch (e) {
         if (e===$stop) {
           return { cont:8, ex:e, again:true; }; // branch to finally
         }
         return { cont:7, ex:e, again:true; }; // branch to catch
      }
    },
    function() { // [6] (internal)
      try {
        return { cont:8, fall:true, again:true};// this falls through to finally
      } catch (e) {
         if (e===$stop) {
           return { cont:8, ex:e, again:true; }; // branch to finally
         }
         return { cont:7, ex:e, again:true; }; // branch to catch
      }
    },
    function() { // [7] (internal, catch(e))
      // note that e has block-level scope; this is desugared out.
      $catch$e = arguments[0];
      try {
        log($catch$e);
        delete arr[i];
        $catch$e = null; // free!
        return { cont:8, fall:true, again:true}; // fall through to finally
      } catch (e) {
        return { cont:8, ex:e, again:true; }; // branch to finally
      }
    },
    function() { // [8] (internal, finally)
      $finally$ex = arguments[0];
      $finally$fall = arguments[1];
      baz(i);
      if ($finally$fall) return 9; // after try
      throw $finally$ex;
    },
    function() { // [9] (internal)
      return 10; // after if
    },
    function() { // [10] (internal)
      // implicit increment, belonging to for loop
      i++;
      return 1; // loop!
    },
    function() { // [11] (internal)
      throw $stop;
    }
  ]);
}

// Using this helper to construct the generator object:

function Generator(cont_this, cont_stop, cont_array) {
  this._cont_this = cont_this;
  this._cont_array = cont_array;
  this._cont_next = cont_array[0];
  this._first = true;
  this._closed = false;
  this._cont_stop = cont_stop; // our stand-in for StopIteration
}
Generator.prototype = {
  next: function() {
    var undef;
    return this.send(undef);
  },
  send: function(val) {
    var undef;
    if (this._first) {
      this._first = false;
      if (val !== undef) { throw new TypeError(); }
    }
    return this._send(null, val);
  },
  'throw': function(ex) {
    return this._send(ex, null);
  },
  close: function() {
    if (this._closed) { return; }
    try {
      // note that catch clauses have to be modified to ignore StopIteration
      this['throw'].call(this, this._cont_stop);
    } catch (e) {
      if (e!==this._cont_stop) { throw e; }
    } finally {
      // should be impossible to catch this._cont_stop, so this._send should
      // have already closed the generator.
      console.assert(this._closed);
    }
  },
  _close: function() {
    console.assert(!this._closed);
    this._closed = true;
    // free memory
    this._cont_this = null;
    this._cont_array = null;
    this._cont_next = null;
  },
  _send: function(exception, value) {
    try {
      if (this._closed) { throw StopIteration; }
      var r;
      while (true) { // this lets us do a simpler CPS conversion of loops
        r = this._cont_next.call(this._cont_this, exception, value);
        exception = value = null;
        if (typeof(r)==='number') {
          this._cont_next = this._cont_array[r];
        } else {
          this._cont_next = this._cont_array[r.cont];
          if (r.again) {
            value = r.fall; // fallthrough, for finally blocks
            exception = r.ex;
          } else if (r.ex) {
            throw r.ex;
          } else {
            return r.ret;
          }
        }
      }
    } catch (e) {
      this._close();
      if (e===this._cont_stop) { throw StopIteration; }
      throw e;
    }
  }
};

//------------------------------------
for (o in ...) {
  ...
}
maps to:

$it=Iterator(...,true);
while(true){
  try {
    o = $it.next();
  } catch (e) {
    if (e===StopIteration) { break; } // how does this work w/ generators?
    throw e;
  }
  ...
}

for example,

for (prop in obj) {
  yield prop;
}

maps to:

XXX FILL ME IN.
