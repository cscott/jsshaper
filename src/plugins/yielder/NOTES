Support yield via a limited-scope CPS conversion.

Pass in value and exception as function arguments to avoid creating objects
on every closure invocation.  Refer to these as arguments[0] and arguments[1]
to avoid pollution the name space.

Pass in array of continuations to Generator constructor to avoid
exposing it to namespace, then use integers instead of functions
as values of the cont: property in return values.

Optimize looping return as common case (ie, return a simple integer
in this case, instead of creating an object wrapper).   This makes loops
as fast as possible.

// Sample source for yield conversion:

function bat(arr) {
  var i;
  // [0]
  for (i=0; i<arr.length; i++) {
     // [1]
     if (test.apply(arr[i], arguments)) {
       // [2]
       try {
         // [3]
         something();
         var j = /* [4] */yield arr[i];
         if (j) {
           // [5]
           something(j);
           return;
         }
         // [6]
       } catch (e) {
         // [7]
         log(e);
         delete arr[i];
       } finally {
         // [8]
         baz(i);
       }
       // [9]
     }
     // [10]
  }
  // [11]
  return;
}

// This gets converted to:

function bat(arr) {
  var $stop = {};
  var $arguments = arguments; // necessary because original uses 'arguments'
  var $catch$e;               // necessary because original has catch
  var $finally$ex;            // necessary because original has finally
  var $finally$fall;          // necessary because original has finally
  var i, j;
  return new Generator(this, $stop, [
    function() { // [0] (external, but first: don't need to check arguments[0])
       i = 0;
       return 1; // looping continuation
    },
    function() { // [1] (internal)
       // internal looping continuation, don't need to check arguments[0] for ex
       // "if (!(i < arr.length)) break;"
       if (i >= arr.length) { return 11; /* looping continuation, after loop */ }
       if (test.apply(arr[i], $arguments)) {
           return 2;
       }
       return 10;
    },
    function() { // [2] (internal)
       return 3; // top of try
    },
    function() { // [3] (internal)
       try {
         something();
         return { cont: 4, ret: arr[i] }; // yield
       } catch (e) {
         if (e===$stop) {
           // (would rethrow e if there wasn't a finally block)
           return { cont:8, ex:e, again:true; }; // branch to finally
         }
         return { cont:7, ex:e, again:true; }; // branch to catch
       }
    },
    function() { // [4] (external)
      try {
        // external continuation, need to check arguments[0]
        if (arguments[0]) { throw arguments[0].ex; }
        j = arguments[1];
        if (j) return 5;
        return 6;
      } catch (e) {
         if (e===$stop) {
           return { cont:8, ex:e, again:true; }; // branch to finally
         }
         return { cont:7, ex:e, again:true; }; // branch to catch
      }
    },
    function() { // [5] (internal)
      try {
        something(j);
        throw $stop; // return
      } catch (e) {
         if (e===$stop) {
           return { cont:8, ex:e, again:true; }; // branch to finally
         }
         return { cont:7, ex:e, again:true; }; // branch to catch
      }
    },
    function() { // [6] (internal)
      try {
        return { cont:8, fall:true, again:true};// this falls through to finally
      } catch (e) {
         if (e===$stop) {
           return { cont:8, ex:e, again:true; }; // branch to finally
         }
         return { cont:7, ex:e, again:true; }; // branch to catch
      }
    },
    function() { // [7] (internal, catch(e))
      // note that e has block-level scope; this is desugared out.
      $catch$e = arguments[0];
      try {
        log($catch$e);
        delete arr[i];
        $catch$e = null; // free!
        return { cont:8, fall:true, again:true}; // fall through to finally
      } catch (e) {
        return { cont:8, ex:e, again:true; }; // branch to finally
      }
    },
    function() { // [8] (internal, finally)
      $finally$ex = arguments[0];
      $finally$fall = arguments[1];
      baz(i);
      if ($finally$fall) return 9; // after try
      throw $finally$ex;
    },
    function() { // [9] (internal)
      return 10; // after if
    },
    function() { // [10] (internal)
      // implicit increment, belonging to for loop
      i++;
      return 1; // loop!
    },
    function() { // [11] (internal)
      throw $stop;
    }
  ]);
}

// Using this helper to construct the generator object:

function Generator(cont_this, cont_stop, cont_array) {
  this._cont_this = cont_this;
  this._cont_array = cont_array;
  this._cont_next = cont_array[0];
  this._first = true;
  this._closed = false;
  this._cont_stop = cont_stop; // our stand-in for StopIteration
}
Generator.prototype = {
  next: function() {
    var undef;
    return this.send(undef);
  },
  send: function(val) {
    var undef;
    if (this._first) {
      this._first = false;
      if (val !== undef) { throw new TypeError(); }
    }
    return this._send(null, val);
  },
  'throw': function(ex) {
    return this._send({ex:ex},null);
  },
  close: function() {
    if (this._closed) { return; }
    try {
      // note that catch clauses have to be modified to ignore StopIteration
      this['throw'].call(this, this._cont_stop);
    } catch (e) {
      if (e!==this._cont_stop) { throw e; }
    } finally {
      // should be impossible to catch this._cont_stop, so this._send should
      // have already closed the generator.
      console.assert(this._closed);
    }
  },
  _close: function() {
    console.assert(!this._closed);
    this._closed = true;
    // free memory
    this._cont_this = null;
    this._cont_array = null;
    this._cont_next = null;
  },
  _send: function(exception, value) {
    if (this._closed) { throw StopIteration; }
    try {
      var r;
      while (true) { // this lets us do a simpler CPS conversion of loops
        r = this._cont_next.call(this._cont_this, exception, value);
        exception = value = null;
        if (typeof(r)==='number') {
          this._cont_next = this._cont_array[r];
        } else {
          this._cont_next = this._cont_array[r.cont];
          if (r.again) {
            value = r.fall; // fallthrough, for finally blocks
            exception = r;  // r.ex contains exception; r is wrapper
          } else {
            return r.ret;
          }
        }
      }
    } catch (e) {
      this._close();
      if (e===this._cont_stop) { throw StopIteration; }
      throw e;
    }
  }
};

//------------------------------------
for (o in ...) {
  ...
}
maps to:

$it=Iterator(...,true);
while(true){
  try {
    o = $it.next();
  } catch (e) {
    if (e===StopIteration) { break; } // how does this work w/ generators?
    throw e;
  }
  ...
}

for example,

function props(obj) {
    for (prop in obj) {
        yield prop;
    }
}

maps to:

function props(obj) {
    var $stop = {};
    var $it$0, prop;
    var $block = {};
    var $catch$e;
    return new Generator(this, $stop, [
        function/*[0]*/() {
            $it$0=Iterator(obj,true);
            return 1;
        },
        function/*[1]*/() {
            // "if (!true) ..." loop check omitted
            return 2;
        },
        function/*[2]*/() {
            try {
                prop=$it$0.next();
                return 6;
            } catch ($e$1) {
                if ($e$1===$stop) { throw $e$1; }
                return { cont:3, ex:$e$1, again:true };
            }
        },
        function/*[3]*/() {
            $catch$e = arguments[0].ex;
            if ($catch$e===StopIteration) return 4;
            else return 5;
        },
        function/*[4]*/() {
            return 8;
        },
        function/*[5]*/() {
            throw $catch$e;
        },
        function/*[6]*/() {
            return {cont:7,ret:prop};
        },
        function/*[7]*/() {
            if (arguments[0]) {
                throw arguments[0].ex;
            }
            arguments[1];
            return 1;
        },
        function/*[8]*/() {
            throw $stop;
        }
    ]);
}
-------------------
Generator.toArray() {
  var a = [];
  for (e in this) { a.push(e); }
  return a;
}

function() {
  var a = [];
  for (var i=0; i<10; i++) {
    try {
      throw i;
    } catch (j) {
      a[i] = function() { return j++; };
    }
  }
  log(a[0]);
  log(a[0]);
  log(a[1]);
  log(a[1]);
}

{ let x=..; .. } -> try { throw void(0); } catch(x) { x=...; ... }

for (let i=...;;i=i+1) { } ->
{let $t; for ($t=...; ;) { let i=$t; ...; i=i+1; $t=i; } }

{
let t;

t = ... t ....;
.. = function() { ... t ... };
}

{$scope = Object.create($scope);
 $scope.t=undefined;

 $scope.t = .... $scope.t ....;

 ... = (function($scope) { return function() { ... $scope.t ... }; })($scope);

 $scope = Object.getPrototypeOf($scope);
}

Only create new $scope objects if the variable escapes; otherwise we can
just gensym the symbol and use var-binding.

---
